mysql数据库：
> 数据只做两件事情：存储数据、检索数据。

1. mysql数据库三范式？

2. mysql索引的数据结构有哪些？
   Hash表
   有序数组
   二叉树
   平衡二叉树(红黑树)
   BTree N叉树
   B+Tree 平衡N叉树
   
3. 什么是索引？使用索引的优缺点？
D:索引的本质是一种数据结构，使用索引的目的是为了更快的检索数据。
  优缺点：
   优点：可以更快、更高效的检索数据
   缺点：索引会占用内存。数据更新时也会要更新索引里的数据，所以更新会变慢。
   (所以：索引不是越多越好，有维护成本)

4.索引有哪些分类？
D: 分类有：
   聚簇索引：叶子节点就是数据节点。一张表只允许存在一个聚簇索引。聚簇索引并不要求唯一。
   非聚簇索引：叶子节点还是索引节点，保存了执行数据节点的指针。
   
   主键索引：一种特殊的唯一索引。
   唯一索引：一个或多个字段组合起来建立的索引，这几个字段组合起来的值在表中不可以重复。
     区别：唯一索引列允许null值。主键索引列不允许null值。一张表最多建立一个主键索引。
   
   单例索引：只包含一个字段的索引
   复合索引：包含多个字段的索引。字段的顺序很重要，涉及到是否可以使用到索引
   
   (聚簇索引默认就是主键索引。如果表中没有主键，InnoDB会选择一个唯一的非空索引来代替。如果没有这样的索引，InnoDB会隐式的定义一个主键来做为聚簇索引)

5. mysql主键索引、非主键索引、聚簇索引、非聚簇索引的区别？
D: mysql InnoDB数据引擎中，索引的数据结构是B+Tree形式。
   聚簇索引：将数据存储与索引放到一起，索引结构的页子节点保存了整行数据。
   非聚簇索引：将数据存储与索引分开存储，索引结构的页子节点保存指向数据节点的指针或位置。

   主键索引的叶子节点：存放的是整行数据。
   非主键索引的叶子节点：存放的是主键的值。

6. 什么是最左前缀原则？
   InnoDB使用B+Tree来作为索引的数据结构。
   在B+Tree结构中，索引项是按照索引定义里面出现的字段顺序排序的。在查询的时候只要定位到最左边的数据，然后依次向右遍历寻找就可以。

7. 为什么建议使用主键自增的索引？
   InnoDB使用B+Tree来作为索引的数据结构，由于B+Tree是有序的。使用自增主键可以保证后插入的主键值都比前面的大，只需要按顺序在后面插入就行。
   如果主键值不是自增的，插入有可能会移动叶子节点的数据，如果叶子节点数据满了，还需要进行页分裂操作。会影响插入性能。

8. 一条sql语句的执行流程？
D: Mysql整体由server层和存储引擎层组成，service负责 视图、函数、存储过程等。
   server层由：连接器、查询缓存、分析器、优化器、执行器等，涵盖了MySQL的大多数核心功能，以及所有的内置函数(日期、时间、机密函数)等，
              所有跨存储引擎的功能都在这一层实现，如 存储过程、触发器、视图等。
   存储引擎层：负责数据的存储和提取。架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。
   MySQL5.5版本后，默认的存储引擎是InnoDB。
   连接器：
     a. 负责跟客户端建立连接
     b. 获取用户权限
     c. 维持和管理连接
   查询缓存：MySQL有查询请求过来后，会先判断查询缓存中之前是否执行过这条语句。执行过的SQL语句会以key-value的形式缓存在内存中。如果缓存中有就直接返回，如果没有就继续
            往下执行。执行完成后，执行结果会被存入查询缓存中。但实际开发中，不建议使用查询缓存。占内存且失效频繁，只要有对一个表的更新，这个表上的所有查询缓存都会失效。
            MySQL8.0版本已经删除此功能。
   分析器：对SQL语句做解析，分析器先会做“词法解析”
   优化器:
   执行器：
   
9. [一条sql语句执行很慢的原因？](https://blog.csdn.net/m0_37907797/article/details/103347579)
D: 分类讨论
第一：大多数情况是正常的，偶尔很慢。sql语句本身应该是没有问题的。
第二：在数据量不变的情况下，这条sql一直很慢。
  第一种情况：
    a. 数据库在刷脏页，如：redo log写满了需要同步磁盘。
    【刷脏页：我们在插入或更新数据的时候，数据库会在内存中把对应的数据更新后，写入redo log，并不会马上同步持久化到磁盘。这是mysql的WAL技术。等到空闲的时候通过redo log把
    数据同步到磁盘。但redo log是由大小限制的，如果更新太频繁redo log写满了。这个时候只能暂停其他操作来同步数据到磁盘，就会导致我们正常执行的SQL语句突然慢了】
    b. 执行sql刚好遇到锁，如：表锁、行锁等。可以通过 show processlist 命令来查看当前SQL的执行状态。
  第二种情况：
    a. sql没有索引，或者有索引但没用到。
       在索引字段上进行计算、或使用函数会导致索引失效。
    b. sql有索引，但经过mysql优化器优化后，并没有用到或选错了。[使用索引不如走全表扫描，判断扫描行数。是否使用临时表。是否需要排序。都会影响索引的选择]
       mysql是如何预测是否使用索引的：通过索引区分度来判断。一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引区分度越高。区分度也称为基数。
       区分度越高，基数越大，意味着使用索引查询越有优势。
       索引的基数[区分度]怎么来：通过采样，即遍历部分数据来获取。
       
10. 如何强制指定索引？
   force index(ind)
   
11.   




















































12. Mysql中数据类型约束？
    int(11),tinyint(4)表示什么？
    varchar(225),char(225)表示什么？
D: 数据类型(M)来约束数据，其中M在不同的数据类型中表示含义不同。
   整数类型：mysql已经限制了整数类型的取值范围。tinyint 占1个字节(-128到127) int|integer 占4个字节(-2^31到2^31-1>)
      [整数类型的取值是定长，其容量不会随着约束的变化而变化。]也就是说int(10)和int(8)一样占用4个字节,tinyint(4)和tinyint(10)一样占用1个字节。
      整数类型后面的约束：不是表示数据长度，只是表示数据在显示时的最小长度。tinyint(1)表示最短显示1个字符，tinyint(2)表示最短显示2个字符。
          当字符长度超过M时，相当于啥都没发生。当字符长度小于M时，就需要拿指定的某个字符来填充，如：zerofull(用0填充)。
          设置tinyint(2) zerofull时，插入1会显示 01; 设置tinyint(4) zerofull时，插入1会显示 0001。
          如果没设置zerofull，约束M是无用的。
   字符串类型：varchar是变长，根据实际需要来分配长度。char是定长。       
       varchar类型：最大长度65535，但实际不能存这么多。因为需要利用1-2个字节来存储数据的长度，如果字段为非空，还需要一个字节来标识不可为空。
       varchar(100)与char(100)对于存储一个实际长度为90的字符数据，其磁盘存储空间是相同的。但对于内存的消耗是不同的，内存使用约束定义的大小来保存值。
           也就是100个字符空间。这对于排序或使用临时表等需要内存来实现的作业会产生较大影响，影响查询效率。
           (Mysql创建临时表时，varchar会转换成char,转换后的char长度就是varchar约束定义的长度，在内存中占用的空间变大，在排序统计时需要扫描就越多，时间越久)
       char类型：适合存储长度相同的数据，如MD5加密后的用户密码，身份证信息等。  
[mysql中整数类型后面的数字，比如int(11)，11代表11个字节吗](https://www.cnblogs.com/lmg-jie/p/10394203.html)         
[varchar(100)和varchar(10)的区别](https://www.cnblogs.com/zhuyeshen/p/11642211.html)    



















































13. Mysql单表超过500W行数据或者单表容量超过2GB，要进行分库分表？
D：实际上，是否需要分库分表要看MYSQL的配置，及服务器硬件配置。如果硬件配置足够好，InnoDB buffer size足够大，可以把索引完全装载到内存中，查询不会有问题。
[MySQL单表数据不要超过500万行：是经验数值，还是黄金铁律？](https://segmentfault.com/a/1190000019565641)   











































14. Mysql主从复制原理？
D：- Mysql开启binlog
     a. vi /etc/my.cnf
     b. log-bin=mysql-bin  # binlog日志名称
        binlog-format=ROW  # binlog日志格式
        expire_logs_days=7 # binlog日过过期清理时间
        max_binlog_size=100m # 每个binlog日志文件大小
   - binlog的常见格式区别？
     [查看binlog日志格式：show global variables like '%binlog_format%';]
     a. statement : 记录每一条修改的sql语句。日志文件小，节约IO，性能高; 准确性差，对一些系统函数不能准确复制 如：now() uuid()等
     b. row : 记录每行数据的实际变更。不记录SQL语句的上下文信息。日志文件大，网络IO和磁盘IO大。能准确复制所有数据的变更。
     c. mixed : statement和row模式的混合。   
   - 主从复制原理：
     a. 配置好主从同步，从库启动并连接主库。
     b. 主库执行更新事件后，记录日志到binlog。
     c. 主库创建 binlog dump thread线程，把binlog内容发送到从库
     d. 从库创建IO线程，读取主库传过来的binlog内容并写入relay log中继日志中。
     e. 从库创建SQL线程，读取relay log日志，更新到数据库
     f. 主库会为每一个连接到主库的从库创建一个binlog dump tread，每个从库都有自己得IO线程和SQL线程。
   
15. Mysql CPU负载飙升问题排查？
D: 如果CUP负载很高，但内存和IO都正常，这种情况下很大概率是索引有问题。   
   
   
16. MySQL的 MVCC\WAL\NBL\crash-save?
D:    