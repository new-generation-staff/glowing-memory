# 自定义线程池
> 

### 一、为什么使用


### 二、线程池说明
```markdown
1. 为什么不允许使用Exceutors创建线程池
   通过ThreadPoolExceutor方式创建线程池方式，可以让开发同学更加明确线程池的运行规则，规避资源耗尽风险
   
   
2. 使用Exceurtors创建线程池的方式：
   - newFixedThreadPool(int nThreads)         创建一个可重用固定线程数的线程池，以共享无界队列方式来运行这些线程
   - newSingleThreadExecutor()                创建一个使用单worker线程的Executor，以无界队列方式来运行该线程
   - newCachedThreadPool()                    创建一个可根据需要创建新线程的线程池，但在以前构造的线程可用时将重用它们      
   - newScheduledThreadPool(int corePoolSize) 创建一个定长线程池，支持定时及周期性任务
   
   问题：
     FixedThreadPool和SignleThreadExecutor 允许的【最大请求队】(LinkedBlockingQueue)列长度为：Integer.MAX_VALUE，可能会堆积大量请求导致OOM
     newCachedThreadPool和ScheduledThreadPool 运行时【创建线程】数量为：Integer.MAX_VALUE，可能会创建大量线程，导致OOM
    
3. ThreadPoolExecutor自定义线程池：
   ① 可根据自己需求定义：拒绝策略，如果线程过多，任务过多时如何处理
   ② 补充线程信息：如线程名称等 这在将来帮助排查bug方面有很大帮助
   ③ 可以通过ThreadPoolExecutor的beforExecute()\afterExecute()和terminated()方法拓展对线程池运行前后不同阶段的控制，如日志打印等
   ④ 可自定义线程名称、组、优先级等信息，包括设置为守护线程等 
   
   
4. ThreadPoolExecutor的本质
   public ThreadPoolExecuotr(
            int corePoolSize,          //指定线程池的核心线程数量
            int maxmumPoolSize,        //指定了线程池里的最大线程数量
            long keepAliveSize,        //当线程池数量大于corePoolSize时，多出来的空闲线程，多久被销毁
            TimeUnit unit,             //时间单位
            BlockingQueue<Runnable> workQueue,  //任务队列，用于存放 提交但未执行的任务
            ThreadFactory threadFactory,        //线程工厂，用于创建线程 一般可以用默认的
            RejectedExecutionHandler handler    //拒绝策略，当任务过多的时候，如何拒绝
   ) 
   
   ① 核心数: 线程池维护线程的最少数量，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。
   ② 最大数: 线程池维护线程的最大数量，它表示在线程池中最多能创建多少个线程；这个参数是跟后面的阻塞队列联系紧密的；只有当阻塞队列满了，如果还有任务添加到线程池的话，会尝试new 一个Thread的进行救急处理，立马执行对应的runnable任务；如果继续添加任务到线程池，且线程池中的线程数已经达到了maximumPoolSize，那么线程就会就会执行reject操作。
   ③ 存活时间: 线程池维护线程所允许的空闲时间，表示线程没有任务执行时最多保持多久时间会终止；默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用；即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法并设置了参数为true，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的阻塞队列大小为0；（这部分通过查看ThreadPoolExecutor的源码分析--getTask()部分）
   ④ 时间单位: 线程池维护线程所允许的空闲时间的单位，参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性（时间单位）。
   ⑤ 缓冲队列: 线程池所使用的缓冲队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择
       ArrayBlockingQueue:  有界队列，线程数会大概率保持coreSize上，队列满了会达到MaxSize
       LinkedBlockingQueue: 无界队列，队列最大长度为Integer.MAX_VALUE
       SynchronousQueue:    直接提交队列，在大量任务时会启用等量线程去处理。
     ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。
   ⑥ 决绝策略
       ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。（默认handle）
       ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
       ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
       ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。
   
   线程池提交任务方式主要有两种：
   ① execute()  无返回值，主要用于无返回值的任务提交
   ② submit()   有返回值，返回Future对象，Future模式
   
     
  
5. 推荐根据不同业务配置不同的线程池
   为不同的业务配置不同的线程池，防止因为某些业务异常影响到整个项目的健壮性。
   

6. 多线程的实现方式
   ① 继承Thread类
   ② 实现Runnable接口
   ③ 实现Callable接口
   ④ 使用ThreadPoolExecutor线程池
    
   Thread类和Runnable接口没有返回结果，Callable和ThreadPoolExecutor的submit方法可以拿到线程执行结果 
  
7. 如何使用好线程池
   ① 合理设置线程池数量
   ② 合理配置线程参数
   ③ 利用Hook嵌入行为
   ④ 不把同步等待其他任务执行结果的任务放入线程池
   ⑤ 可能长时间操作的任务放入线程池要慎重
   ⑥ 关闭线程池
   
   线程池数量设置-分实际情况来考虑：
     A: 若是计算密集型,线程数可设置为： CPU核数+1 ,也可设置CPU核数*2(最大)
     B: 若是IO密集型,线程数可设置为：CPU核数/(1-阻塞系数) 阻塞系数一般在：0.8~0.9 也可是0.8和0.9
   线程池参数设置：
     A: 不要选择没有上限限制的线程数量，也不要使用无界任务队列
     B: 慎用newCachedThreadPool,根据实际场景设置自己的兜底策略进行补偿，不要使用JDK自带的拒绝策略
   ThreadPoolExecutor提供了beforExecute()和afterExecute()钩子方法，来对线程执行前后进行扩展  
   

8. 使用线程池的执行流程:
   ★ 处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，则会使用handler处理被拒绝的任务。
   当一个任务通过execute(Runnable)方法欲添加到线程池时：
     ① 如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。
     ② 如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。
     ③ 如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。
     ④ 如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。
       也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，则会使用handler处理被拒绝的任务。
     ⑤ 当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样以来，线程池可以动态的调整池中的线程数


9. 使用线程池的一些陷进
    ① 死锁
    ② 资源不足
    ③ 并发错误
    ④ 线程泄露
    ⑤ 请求过载
    

```

> 示例代码
```java

/**
 * 1. 当一个任务被提交到线程池时，首先查看线程池的核心线程是否都在执行任务，否就选择一条线程执行任务，是就执行第二步。
 * 2. 查看核心线程池是否已满，不满就创建一条线程执行任务，否则执行第三步。
 * 3. 查看任务队列是否已满，不满就将任务存储在任务队列中(SynchronousQueue同步队直接执行第四步)，否则执行第四步。
 * 4. 查看线程池是否已满，不满就创建一条线程执行任务，否则就按照策略处理无法执行的任务。
 */
@Configuration
public class ThreadPoolTaskConfig {

    @Bean
    public Executor executor(){
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        //此方法返回可用处理器的虚拟机的最大数量; 不小于1
        int core = Runtime.getRuntime().availableProcessors();
        executor.setCorePoolSize(core);      //设置核心线程数
        executor.setMaxPoolSize(core*2 + 1); //设置最大线程数
        executor.setKeepAliveSeconds(3);     //除核心线程外的线程存活时间
        executor.setQueueCapacity(40);       //如果传入值大于0，底层队列使用的是LinkedBlockingQueue,否则默认使用SynchronousQueue
        executor.setThreadNamePrefix("thread-execute");     //线程名称前缀
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());   //设置拒绝策略
        return executor;
    }
}
```

- 参考文档

> 对各个参数有细致说明，会导致OOM情况 介绍各个队列介绍及优缺点

[线程池各个参数详解以及如何自定义线程池](https://blog.csdn.net/qq_20009015/article/details/85953364)

> 如何设置线程池，有一些具体的参考指标

[学习如何创建自定义线程池](https://blog.csdn.net/jisuanji12306/article/details/82667728)

> 针对不同业务线配置不同线程池

[SpringBoot2.x整合线程池ThreadPoolTaskExecutor](https://www.jianshu.com/p/3d875dd9d5db)

> 实操案例demo

[Callable+ThreadPoolExecutor实现多线程并发并获得返回值](https://blog.csdn.net/kity9420/article/details/80740466)

> 示例代码说明

[SpringBoot配置ThreadPoolTaskExecutor](https://blog.csdn.net/weixin_43142697/article/details/83788228)

> 线程池参数设置-详细说明

[ThreadPoolExecutor 自定义线程池](https://blog.csdn.net/qq_33029793/article/details/94553909)

> 使用线程池的一些陷阱，高效线程池使用指南

[Java线程池实现](https://www.cnblogs.com/anymk/p/11991740.html)

> 自定义线程池配合异步任务

[使用@Async异步调用，ThreadPoolTaskScheduler线程池，使用Future以及定义超时](https://blog.csdn.net/BiandanLoveyou/article/details/83586356)

---
> 有错误示范案例

[使用线程池你需要注意这几点](https://mp.weixin.qq.com/s/G5MsC06t2upipoOrFybJ0A)

-----