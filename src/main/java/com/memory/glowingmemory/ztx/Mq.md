# MQ
> 削峰填谷、异步解耦

### 一、项目中哪里用到MQ了
> MQ可以使用哪些业务场景，解决什么问题

```markdown
1. 业务场景：
   ① 异步：用户登录，异步发送登录短信、记录日志。处理与当前业务不强相关的逻辑，耗时操作等
   ② 解耦：数据中台推送业务数据到MQ，各业务线去监听获取自己想要的数据。每月生产采购经理指数，发送指数给各订阅方
   ③ 削峰：大促或秒杀场景中，高并发场景大量请求需要服务器承担很大压力。通过MQ把请求做缓冲，服务端限流消费，减轻服务器压力。保证服务可用
   
好处：
  ① 异步：使用MQ后，只关注核心业务。把与业务不是强相关的逻辑单独处理，可以快速响应。提升用户体验
  ② 解耦：多个业务需要一个业务的数据时，通过MQ实现业务解耦。生产数据方只需要关注业务数据的生产，然后发送到MQ，各业务线监听队列获取数据实现自己的业务逻辑。
         实现业务解耦，可以快速响应需求变更。增强代码的健壮性，可维护性。
  ③ 削峰：高并发请求一般处于特定的场景或时间段，通过MQ削峰可以实现请求的缓冲。高并发场景下，大量请求堆积MQ，服务端限流消费，保证服务可用性。
         高峰期过后，MQ积压消息可以快速消费。          
```


### 二、为什么使用MQ
> MQ的优缺点

```markdown
优点：
1. 异步
2. 解耦
3. 削峰


缺点：
1. 降低系统可用性：系统引入的外部依赖越多，风险越高
2. 增加系统复杂性：使用MQ要解决，消息丢失、消息重复消费、顺序性等问题，使得系统复杂度提升
3. 数据一致性问题：如何保证各业务逻辑中数据是一致的

```

### 三、`Kafka、RabbitMQ、RocketMQ` 各自的原理，技术选型的考虑
> 分析各MQ的使用场景，技术选型的标准 

```markdown
   参考项             KAFKA                       ROCKET                  RABBITMQ
1. 单机吞吐量：        KAFKA          >            ROCKET         >        RABBITMQ
2. 时效性：          延迟在ms级别                  ms级别                  微妙级，延迟最低
3. 可用性：     分布式架构，多副本。可用性高     分非常高，布式架构            主从，或镜像
4. 消息可靠性：   经过优化可以做到0丢失          经过优化可以做到0丢失         基本不丢失
5. 功能支持：     功能简单，主要大数据领域       功能完善，扩展性好           并发性能好，延迟低
6. 社区活跃度：      
7. 文档支持完备：                              

```



### 四、MQ如何保证高可用机制
> 不同MQ的高可用机制不同，实现原理不同

```markdown

```

### 五、MQ如何保证100%消息必达,消息可靠传输
> 使用消息队列如何保证消息不丢失

```markdown
 MQ的丢消息分三种情况：生产者丢失 | MQ丢失 | 消费者丢失

- RabbitMQ保证消息不丢失 
1. 生产者丢数据: 生产者在发消息给MQ时，可能因为网络问题导致消息丢失
   ① 事务机制:    channel.exSelect\channel.txCommit\channel.txRollback
   ② confirm模式: 在生产者那里开启confrim模式，每次写消息都会分配一个唯一ID，写入MQ会回传ACK消息。如果失败会回调nack接口，可以做后续处理 重试或其它
2. MQ丢数据
   ① 开启消息持久化
     创建queue的时候将其设置为持久化,可以保证RabbitMQ持久化queue里的元数据，但不会持久化queue里的数据
     发送消息时，将deliveryMode 设置为：2，将消息持久化到磁盘
     必须同时设置两个持久化
3. 消费者丢数据：
   ① 手动ACK。关闭RabbitMQ的自动ACK机制，消息消费完成后手动进行ACK。
 
- RocketMQ保证消息不丢失
1. 会导致消息丢失的业务场景：
   ① 生产者将消息发送给MQ时，若出现网络抖动或者通信异常问题，消息可能会丢失。
   ② MQ收到消息还没完成异步刷盘时,MQ宕机导致消息丢失; 消息写入磁盘但为做备份，一旦磁盘损坏消息丢失。
   ③ 消费者接受到MQ消息，即通知MQ消费成功消息。
   
2. 解决方案： 
   ① 生产者使用MQ自带的事务机制来发送消息
     流程：
     a. 生成者发送Half消息到RocketMQ中，此时消费者是无法消费Half消息的。若half消息发送失败则执行相应的回滚逻辑
     b. Half发送成功且RocketMQ返回成功响应，则执行生产者的核心链路
     c. 若生成者核心链路执行失败，则回滚，并通知RocketMQ删除Half消息
     d. 若生成者核心链路执行成功，则通知RocketMQ commit Half消息，让消费者可以消费这条数据
     e. 若RocketMQ长时间没有收到生产者commit/rollback的操作，会回调生产者接口查询这条消息到底是commit或rollback
   ② MQ同步刷盘持久化，并做主从或集群部署保障高可用
     a. RocketMQ broker的异步刷盘改为同步刷盘。参数：flushDiskType=SYNC_FLUSH，一旦同步刷盘成功则消息一定持久化到磁盘中。
     b. RocketMQ采用主从或集群部署，防止单点故障
   ③ 消费者手动ACK
     a. 消费者消费消息成功后，返回MQ CONSUME_SUCCESS。若消费者宕机RocketMQ会自动故障转移，将消息发送给其他消费者

3. 消息不丢失带来的影响：
   使用上面的一整套方案可以在使用RocketMQ时保证消息零丢失，但性能和吞吐量也将大幅下降
   ① 使用事务机制传输消息，会比普通消息的传输多很多步骤，消费性能
   ② 同步刷盘相比异步刷盘，同步刷盘存储在磁盘中，异步刷盘消息存储在so_cache内存中，速度不是一个量级
   ③ 主从结构，要将消息从Leader同步给Follower
   ④ 消费时无法异步消费，只能等待同步完成后在通知RocketMQ消费完成
    
```


[RocketMQ消息丢失场景及解决办法](https://blog.csdn.net/LO_YUN/article/details/103949317)

------




### 六、MQ如何保证消息不被重复消费,消息幂等
> 使用消息队列如何保证幂等性 

```markdown
1. 在实际的业务中，MQ发送消息给消费者，消费者消费成功后给MQ响应ACK，MQ删除消息。但因为网络或其他问题导致消费者消费成功，但MQ并没有接受到ACK，那么MQ会重新发送消息给消费者。
2. 在我们的业务中，我们会在消息中携带全局唯一ID。消费者接受消息后先查询消息日志是否已经记录消息，若没有则同步插入数据库消息日志，消费成功后返回ACK。若MQ没收到ACK进行消息重试时，数据库中已经有消费记录，则直接返回ACK。
   (也可以基于数据库的唯一键来进行约束，插入同样的数据会保存)
```

[RocketMQ消息重复消费场景及解决办法](https://blog.csdn.net/LO_YUN/article/details/104135197)

-----




### 消息消费失败的处理方法
```markdown

- RabbitMQ
1. 


- RocketMQ
1. RocketMQ消息消费成功后，会返回：ConusmerConcurrentlyStatus.CONSUMER_SUCCESS状态。如果失败则返回RECONSUME_LATER，过一会重新消费
2. 消费失败的消息会进入到：重试队列。RocketMQ对于重试消息的处理是先保存至Topic名称为：SCHEDULE_TOPIC_xxx 的延迟队列中，后台定时任务按照对应的时间Delay后
   重新保存至%RETRY%+consumerGroup的重试队列中
3. 参数messageDelayLevel可以设置重试机制，有16个级别。
4. 如果重试16次后，任然消费不成功。该消息会被放入：死信队列。名称为：%DLQ%+原队列名称
5. 如果还不死心，可以开启一个后台线程不断扫描死信队列然后继续重试

```

[RocketMQ消费消息失败的处理办法](https://blog.csdn.net/LO_YUN/article/details/104301740)

-----

### 七、MQ如何保证顺序性
> 

```markdown

```

### 八、MQ如何处理消息延时及过期失效
> 

```markdown

```

### 九、MQ队列满了如何处理,几百万消息积压如何处理
> 

```markdown

```

### 十、如何设计一个MQ，说说你的思路
> 

```markdown

```


